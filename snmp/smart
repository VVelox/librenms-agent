#!/usr/bin/env perl
#Copyright (c) 2017, Zane C. Bowers-Hadley
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without modification,
#are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
#WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
#INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
#BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
#DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
#LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
#THE POSSIBILITY OF SUCH DAMAGE.

# Add this to snmpd.conf like below.
# extend smart /etc/snmp/smart
#
# Then add to root's cron tab, if you have more than a few disks.
# */3 * * * * /etc/snmp/smart -u

# This is the drives you want to check for.
my @disks=(
        'da0',
        'da1',
        'da2',
        'da3',
        'da4',
        'da5',
        'da6',
        'da7',
        'da8',
        'da9',
        'da10',
        'da11',
        'da12',
        );

# This is the path to smartctl
my $smartctl='/usr/bin/env smartctl';

# The cache file to use.
my $cache='/var/cache/smart';

##
## You should not need to touch anything below here.
##
use warnings;
use strict;
use Getopt::Std;

$Getopt::Std::STANDARD_HELP_VERSION = 1;
sub main::VERSION_MESSAGE {
        print "SMART SNMP extend 0.0.0\n";
};


sub main::HELP_MESSAGE {
        print "\n".
                "-u   Update '".$cache."'\n";
}

#gets the options
my %opts=();
getopts('u', \%opts);

#if set to 1, no cache will be written and it will be printed instead
my $noWrite=0;

# if no -u, it means we are being called from snmped
if ( ! defined( $opts{u} ) ){
        # if the cache file exists, print it, otherwise assume one is not being used
        if ( -f $cache ){
                my $old='';
                open(my $readfh, "<", $cache) or die "Can't open '".$cache."'";
                read($readfh , $old , 1000000);
                close($readfh);
                print $old;
                exit 0;
        }else{
                $opts{u}=1;
                $noWrite=1;
        }
}

$toReturn='';
my $int=0;
while ( defined($disks[$int]) ) {
        my $disk=$disks[$int];
        my $output=`$smartctl -A /dev/$disk`;

        my %IDs=( '5'=>0,
                          '10'=>0,
                          '173'=>0,
                          '177'=>0,
                          '183'=>0,
                          '184'=>0,
                          '187'=>0,
                          '188'=>0,
                          '190'=>0,
                          '194'=>0,
                          '196'=>0,
                          '197'=>0,
                          '198'=>0,
                          '199'=>0,
                          '231'=>0,
                          '233'=>0,
        );
    
    my @outputA=split( /\n/, $output );
        my $outputAint=0;
        while ( defined($outputA[$outputAint]) ) {
                my $line=$outputA[$outputAint];
                $line=~s/^ +//;
                $line=~s/  +/ /g;

                if ( $line =~ /^[0123456789]+ / ) {
                        my @lineA=split(/\ /, $line, 10);
                        my $raw=$lineA[9];
                        my $id=$lineA[0];

                        # single int raw values
                        if ( 
                                ( $id == 5 ) ||
                                ( $id == 10 ) ||
                                ( $id == 173 ) ||
                                ( $id == 177 ) ||
                                ( $id == 183 ) ||
                                ( $id == 184 ) ||
                                ( $id == 187 ) ||
                                ( $id == 198 ) ||
                                ( $id == 199 ) ||
                                ( $id == 231 ) ||
                                ( $id == 233 )
                                ) {
                                $IDs{$id}=$raw;
                        }

                        # 188, Command_Timeout
                        if ( $id == 188 ) {
                                my $total=0;
                                my @rawA=split( /\ /, $raw );
                                my $rawAint=0;
                                while ( defined( $rawA[$rawAint] ) ) {
                                        $total=$total+$rawA[$rawAint];
                                        $rawAint++;
                                }
                                
                        }

                        # 190, airflow temp
                        # 194, temp
                        if ( 
                                ( $id == 190 ) ||
                                ( $id == 194 )
                                ) {
                                my ( $temp )=split(/\ /, $raw);
                                $IDs{$id}=$temp;
                        }                       
                        
                }

                $outputAint++;
        }

        $toReturn=$toReturn.$disk.','.$IDs{'5'}.','.$IDs{'10'}.','.$IDs{'173'}.','.$IDs{'177'}.','.$IDs{'183'}.','.$IDs{'184'}.','.$IDs{'187'}.','.$IDs{'188'}
              .','.$IDs{'190'} .','.$IDs{'194'}.','.$IDs{'196'}.','.$IDs{'197'}.','.$IDs{'198'}.','.$IDs{'199'}.','.$IDs{'231'}.','.$IDs{'233'}."\n";

    $int++;
}

if ( ! $noWrite ){
        open(my $writefh, ">", $cache) or die "Can't open '".$cache."'";
        print $writefh $toReturn;
        close($writefh);
}else{
        print $toReturn;
}
