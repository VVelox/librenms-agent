#!/usr/bin/env perl
# Author: Zane C. Bowers-Hadley <vvelox@vvelox.net>

=head1 DESCRIPTION

A basic SNMP extend for parsing Privoxy logs for LibreNMS.

=head1 SWITCHES

=head2 -l <logfile>

The Privoxy logfile to use.

If not defined, '/var/log/privoxy/logfile' is used.

=head2 -L <last file>

This is file contains the line from the log file where parsing left off.

By default it is '/var/log/privoxy/lastline'.

=head2 -p

Pretty print the JSON.

=head1 SNMPD SETUP EXAMPLES

=cut


#Copyright (c) 2017, Zane C. Bowers-Hadley
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without modification,
#are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
#WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
#INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
#BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
#DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
#LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
#THE POSSIBILITY OF SUCH DAMAGE.

use strict;
use warnings;
use Carp;
use Getopt::Std;
use File::ReadBackwards;
use JSON;

$Getopt::Std::STANDARD_HELP_VERSION = 1;
sub main::VERSION_MESSAGE {
	print "privoxy log parser SNMP extend 0.0.0\n";
	return;
};

sub main::HELP_MESSAGE {
	print "-l <log file>   The log file to parse.\n".
		"-L <last line file>   The line in the log file at the time is stored here.\n".
		"-p   Pretty print the resulting JSON.\n";

	return;
}

#the privoxy log file
my $log='/var/log/privoxy/logfile';
#this file holds where processing should run till when reading it backwards
my $lastfile='/var/log/privoxy/lastline';

#gets the options
my %opts=();
getopts('pL:l:', \%opts);

my %companies=(
	'33Across'=>0,
	'Adobe'=>0,
	'AppNexus'=>0,
	'Associated Northcliffe Digital'=>0,
	'ATDMT'=>0,
	'Audience Science'=>0,
	'Bounce Exchange'=>0,
	'BURST Media'=>0,
	'Casale Media'=>0,
	'Chartbeat'=>0,
	'Clickthulu'=>0,
	'Comcast'=>0,
	'Conversant'=>0,
	'Cox Media Group'=>0,
	'Criteo'=>0,
	'DataSphere'=>0,
	'Datonics'=>0,
	'Disqus'=>0,
	'DoubleClick'=>0,
	'EroAdvertising'=>0,
	'eXTReMe Tracking'=>0,
	'GamesRevenue'=>0,
	'Google'=>0,
	'Hiveworks Comics'=>0,
	'Improve Digital'=>0,
	'IMR Worldwide'=>0,
	'LKQD Technologies'=>0,
	'Lotame'=>0,
	'MaxCDN'=>0,
	'Medley'=>0,
	'Moat'=>0,
	'Neustar'=>0,
	'Piperka'=>0,
	'Project Wonderful'=>0,
	'Pubmatic'=>0,
	'PubMatic'=>0,
	'PulsePoint'=>0,
	'Quantcast'=>0,
	'RU4.com'=>0,
	'Rubicon Project'=>0,
	'ScorecardResearch'=>0,
	'SlimCut Media'=>0,
	'Smart AdServer'=>0,
	'Smartclip'=>0,
	'Sortable'=>0,
	'StatCounter'=>0,
	'StickyADS'=>0,
	'Trade Desk, The'=>0,
	'Twitter'=>0,
	'Verizon'=>0,
	'WebTrends'=>0,
	'Yahoo'=>0,
	'Yieldbot'=>0,
	'Playtika'=>0,
	'ExoClick'=>0,
	'Amazon'=>0,
	'RoughTed'=>0, # did not come across during my research, but found in uBlockOrigin stuff
	'Tealium'=>0, # did not come across during my research, but found in uBlockOrigin stuff
	);

my @companies_list=keys( %companies );

my %mobileDomains=(
	'playtika.com'=>'0',
	);

my %videoDomains=(
	'lkqd.net'=>'0',
	'smartclip.net'=>'0',
	'freeskreen.com'=>'0',
	);

my %possibleVideoDomains=(
	'mediaplex.com'=>'0',
	);

my %domainToCompany=(
	'atdmt.com'=>'ATDMT',
	'doubleclick.net'=>'DoubleClick',
	'agkn.com'=>'Neustar',
	'360yield.com'=>'Improve Digital',
	'afy11.net'=>'Cox Media Group',
	'crwdcntrl.net'=>'Lotame',
	'lkqd.net'=>'LKQD Technologies',
	'smartclip.net'=>'Smartclip',
	'adadvisor.net'=>'Neustar',
	'mediaplex.com'=>'Conversant',
	'netdna-ssl.com'=>'MaxCDN',
	'yldbt.com'=>'Yieldbot',
	'advertising.com'=>'Verizon',
	'freeskreen.com'=>'SlimCut Media',
	'pro-market.net'=>'Datonics',
	'pubmatic.com'=>'Pubmatic',
	'rubiconproject.com'=>'Rubicon Project',
	'stickyadstv.com'=>'StickyADS',
	'thehiveworks.com'=>'Hiveworks Comics',
	'contextweb.com'=>'PulsePoint',
	'statcounter.com'=>'StatCounter',
	'omtrdc.net'=>'Adobe',
	'2o7.net'=>'Adobe',
	'imrworldwide.com'=>'IMR Worldwide',
	'yahoo.com'=>'Yahoo',
	'bounceexchange.com'=>'Bounce Exchange',
	'google.com'=>'Google',
	'ru4.com'=>'RU4.com',
	'disqusads.com'=>'Disqus',
	'fwmrm.net'=>'Comcast',
	'casalemedia.com'=>'Casale Media',
	'extreme-dm.com'=>'eXTReMe Tracking',
	'quantserve.com'=>'Quantcast',
	'pubmatic.com'=>'PubMatic',
	'adnxs.com'=>'AppNexus',
	'adsrvr.org'=>'Trade Desk, The',
	'datasphere.com'=>'DataSphere',
	'googleadservices.com'=>'Google',
	'googlesyndication.com'=>'Google',
	'chartbeat.net'=>'Chartbeat',
	'piperka.net'=>'Piperka',
	'revsci.net'=>'Audience Science',
	'gamesrevenue.com'=>'GamesRevenue',
	'scorecardresearch.com'=>'ScorecardResearch',
	'fastclick.net'=>'Conversant',
	'medleyads.com'=>'Medley',
	'google-analytics.com'=>'Google',
	'criteo.net'=>'Criteo',
	'webtrendslive.com'=>'WebTrends',
	't.co'=>'Twitter',
	'contextweb.com'=>'PulsePoint',
	'deployads.com'=>'Sortable',
	'tynt.com'=>'33Across',
	'ero-advertising.com'=>'EroAdvertising',
	'and.co.uk'=>'Associated Northcliffe Digital',
	'burstnet.com'=>'BURST Media',
	'clickthulu.com'=>'Clickthulu',
	'projectwonderful.com'=>'Project Wonderful',
	'smartadserver.com'=>'Smart AdServer',
	'moatads.com'=>'Moat',
	'playtika.com'=>'Playtika',
	'roughted.com'=>'RoughTed',
	'tags.tiqcdn.com'=>'Tealium',
	'youtube.com'=>'Google',
	'exoclick.com'=>'ExoClick',
	'amazon-adsystem.com'=>'Amazon',
	);

my @domain_list=keys( %domainToCompany );

#zero each domain
my %domains=%domainToCompany;
my $domains_int=0;
while ( defined( $domain_list[ $domains_int ] ) ){
	$domains{ $domain_list[ $domains_int ] }=0;
	
	$domains_int++;
}

my %protocols=(
	'http'=>0,
	'https'=>0,
	'other'=>0,
	);

#gets the old last line
my $last_line="----------NONE-------\n\n"; #set the default to something that shoul never match
if ( -f $lastfile ){
	open( my $fh, '<' , $lastfile ) or croak "can't read $log $!";
	$last_line=readline($fh);
	close $fh;
}

#init the BW read
my $bw = File::ReadBackwards->new( $log ) or croak "can't read $log $!";

my $new_last_line=undef;
my $last_not_found=1;
while(
	(defined( my $log_line = $bw->readline )) &&
	$last_not_found
	) {
	#save the last line or die
	if (!defined($new_last_line)){
		$new_last_line=$log_line;
	
		open(my $fh, ">", $lastfile) or croak "can't open $lastfile $!";
		print $fh $new_last_line;
		close $fh;
	}

	my $valid_url=1;
	my ( $date, $time, $garbage, $crunch, $blocked, $url );
	if ( $log_line eq $last_line ){
		$last_not_found=0; #we found it, so stop processing it...
		$valid_url=0; #don't process this line as we had previously
	}else{
		#
		
		#break the line apart
		#I am not sure what the item I am shoving into $garbage is
		chomp($log_line);
		( $date, $time, $garbage, $crunch, $blocked, $url ) = split( / /, $log_line, 6 );
		
		#don't process the log turn over line
		my $valid_url=1;
		if ( $url eq 'logfile turned over' ){
			$valid_url=0;
		}
		
	}

	#if we have a valid URL, break it down
	if ( $valid_url ){
		#we may use the URL some time in the future or the like
		my $domain=$url;

		#since we are breaking it down to the URL, we don't care about capitalization
		#and our data is only lowercase
		$domain=lc($domain);

		#figure out what the protocol is
		if (
			# HTTPS proto check
			(
			 ( $domain !~ /^http\:\/\// ) && 
			 ( $domain !~ /^.*\:\/\// ) && # should never see https or the like, but just being sure
			 ( $domain =~ /\:443$/ )
			) || (
			 ( $domain =~ /^https\:\/\// ) && # explicitly check we have a https URL, which I've not seen privoxy throw yet, just domain name and port
			 ( $domain =~ /\:443$/ )				
			)
			){
			$protocols{'https'}++;

			#make sure we have just the domain name
			$domain=~s/https\:\/\///x;
			$domain=~s/\:443$//x
		}elsif(
			# HTTP check
			$domain =~ /^http\:\/\//
			){
			$protocols{'http'}++;

			#make sure we have just the domain name
			$domain=~s/http\:\/\///x;
			$domain=~s/\/.*//x;
		}else{
			# we should enver get there, but if we do, log it
			$protocols{'other'}++;
			
			#make sure we have just the domain name
			$domain =~ s/^.*\:\/\///x;
			$domain=~s/\/.*//x;
		}

		# true for when we the domain is not matched
		my $domain_unmatched=1;

		# the domain we matched
		my $domain_matched;
		
		#first we check for exact domain matches
		my $domain_list_int=0;
		while ( 
			defined( $domain_list[ $domain_list_int ] ) &&
			$domain_unmatched
			){
			my $toMatch=$domain_list[ $domain_list_int ];

			if ( $domain =~ /^$toMatch$/ ){
				$domain_unmatched=0;
				$domain_matched=$domain_list[ $domain_list_int ]
			}
			
			$domain_list_int++;
		}

		#second we check for if it is a subdomain of a domain we have
		$domain_list_int=0;
		while ( 
			defined( $domain_list[ $domain_list_int ] ) &&
			$domain_unmatched
			){
			my $toMatch='.'.$domain_list[ $domain_list_int ];

			if ( $domain =~ /$toMatch$/ ){
				$domain_unmatched=0;
				$domain_matched=$domain_list[ $domain_list_int ]
			}

			$domain_list_int++;
		}

		if ( defined( $videoDomains{ $domain_matched } ) ){
			$videoDomains{ $domain_matched }++;
		}
		if ( defined( $possibleVideoDomains{ $domain_matched } ) ){
			$possibleVideoDomains{ $domain_matched }++;
		}
		if ( defined( $mobileDomains{ $domain_matched } ) ){
			$mobileDomains{ $domain_matched }++;
		}

		#increment the domain matched
		$domains{ $domain_matched } = $domains{ $domain_matched } + 1;

		#increment the company matched		
		my $company=$domainToCompany{$domain_matched};
		$companies{$company}++;
	}
}

# total all video domains hit
my $videoDomains_total=0;
my @videoDomains_list=keys( %videoDomains );
my $videoDomains_int=0;
while ( defined( $videoDomains_list[ $videoDomains_int ] ) ){
	my $domain=$videoDomains_list[ $videoDomains_int ];
	$videoDomains_total= $videoDomains{ $domain } + $videoDomains_total;
	
	$videoDomains_int++;
}

# total all possible video domains hit
my $possibleVideoDomains_total=0;
my @possibleVideoDomains_list=keys( %possibleVideoDomains );
my $possibleVideoDomains_int=0;
while ( defined( $possibleVideoDomains_list[ $possibleVideoDomains_int ] ) ){
	my $domain=$possibleVideoDomains_list[ $possibleVideoDomains_int ];
	$possibleVideoDomains_total = $possibleVideoDomains{ $domain } + $possibleVideoDomains_total;
	
	$possibleVideoDomains_int++;
}

# total all mobile domains hit
my $mobileDomains_total=0;
my @mobileDomains_list=keys( %mobileDomains );
my $mobileDomains_int=0;
while ( defined( $mobileDomains_list[ $mobileDomains_int ] ) ){
	my $domain=$mobileDomains_list[ $mobileDomains_int ];
	$mobileDomains_total = $mobileDomains{ $domain } + $mobileDomains_total;
	
	$mobileDomains_int++;
}

#total blocked
my $total=0;
my $companies_int=0;
while ( defined( $companies_list[ $companies_int ] ) ){
	my $company=$companies_list[ $companies_int ];
	$total=$companies{$company}+$total;
	
	$companies_int++;
}

#put together the object that will be returned
my %toReturn=(
	'total'=>$total,
	'companies'=>\%companies,
	'protocols'=>\%protocols,
	'mobileTotal'=>$mobileDomains_total,
	'mobiledomains'=>\%mobileDomains,
	'videoTotal'=>$videoDomains_total,
	'videoDomains'=>\%videoDomains,
	'possibleVideoTotal'=>$possibleVideoDomains_total,
	'possibleVideoDomains'=>\%possibleVideoDomains,
	'domains'=>\%domains,
	);

#render it
my $j=JSON->new;
if ( $opts{p} ){
        $j->pretty(1);
}
print $j->encode( \%toReturn );
if (! $opts{p} ){
        print "\n";
}
exit 0;
